---
title: "Thesis Präsentation"
subtitle: "Implementing a Scientific Workflow Management System to Conduct the Transition to a Different Reference Genome of a Genetic Analysis Pipeline"
bibliography: references.bib
csl: "ieee.csl"
---

# Einleitung

## Einleitung - Auslöser

::::: {.columns}

:::: {.column width="60%"}
::: {.center-y style='width:60%'}
Wechsel des Referenzgenom in der genetischen Analyse Pipeline

GRCh37 → GRCh38
:::
::::
:::: {.column width="40%"}
::: {.center-y style='width:40%'}
![](images/dna_puzzle.png)
:::
::::
:::::

## Einleitung - Probleme

:::: {.center-y}
::: incremental
- Prozessierungskapazitäten
- Speicherplatz
- Bandbreite
- Prozessierungsdauer
- Architektur
:::
::::

## Einleitung - Ziele

:::: {.center-y}
::: incremental

- Professionalisierung durch Einführung eines\
    **Scientific Workflow Management Systems** (SWfMS) für bestehende "Medical Genetics Sequence Analysis Pipeline" *(megSAP)*

- Mögliche Nutzung von Cloud Infrastruktur prüfen

:::
::::

# Methode

## Methode - Design Science Research

:::: {.blocker}
::: {.center-y}
![Vereinfachter DSR Prozess[^pfeffers]](images/basic_dsr.svg)
:::
::::

[^pfeffers]: Basierend auf @Peffers2007 (vereinfacht)

# Artefakt

## Artefakt - Entscheidung für SWfMS {.smaller}

:::::: {.columns}
::::: {.column width="40%"}
:::: {.center-y style='width:40%; text-align: center'}
![](images/nextflow.png)
::::
:::::
::::: {.column width="60%"}
:::: {.center-y style='width:60%'}
Entscheidung auf Basis der Literaturrecherche

::: incremental
- Domain-specific language
  - Portierbar
  - Versionierbar
- Support bereits eingesetzter Architektur
  - SLURM
  - Singularity
:::
::::
:::::
::::::


## Artefakt - Konvertierung Pipeline zu Nextflow {.smaller}

::::: {.columns}

:::: {.column width="30%"}
::: {.fragment .center-y style='width:30%;text-align: center'}
![Initialer Nextflow Workflow](images/nextflow_dag_v0.1.svg){height="250"}
:::
::::
:::: {.column width="5%"}
::: {.fragment .center-y style='width:5%;text-align: center'}
→
:::
::::
:::: {.column width="30%"}
::: {.fragment style='text-align: center'}
![Nextflow Workflow mit BAM zu FastQ Konvertierung](images/nextflow_dag_v0.2.svg){height="400"}
:::
::::
:::: {.column width="5%"}
::: {.fragment .center-y style='width:5%;text-align: center'}
→
:::
::::
:::: {.column width="30%"}
::: {.fragment style='text-align: center'}
![Finaler Nextflow Workflow](images/nextflow_dag_v0.3.svg){height="400"}
:::
::::
:::::

## Artefakt - Optimierung {.small}
```{python}
import pandas as pd
import plotly.io as pio
import plotly.graph_objects as go
from plotly.subplots import make_subplots

BENE_COLORS = (
    "#47476B",
    "#CDA715",
    "#318986",
)
pio.templates["bene"] = go.layout.Template(
    layout=go.Layout(
        colorway=BENE_COLORS,
        paper_bgcolor='rgba(0,0,0,0)',
    )
)
pio.templates.default = "plotly_white+bene"

df_CPU_v03 = pd.DataFrame(
    {
        "step": ["megSAPma", "megSAPvc", "megSAPcn", "megSAPsv", "megSAPdb"],
        "allocated": [12, 12, 12, 12, 12],
        "used": [12 * 0.287, 12 * 0.531, 12 * 0.086, 12 * 0.157, 12 * 0.017],
        "time": [
            pd.Timedelta("2 hours 54 min"),
            pd.Timedelta("2 hours 54 min") + pd.Timedelta("2 hours 40 min"),
            pd.Timedelta("2 hours 54 min")
            + pd.Timedelta("2 hours 40 min")
            + pd.Timedelta("6 hours 11 min"),
            pd.Timedelta("2 hours 54 min")
            + pd.Timedelta("2 hours 40 min")
            + pd.Timedelta("6 hours 11 min")
            + pd.Timedelta("1 hours 3 min"),
            pd.Timedelta("2 hours 54 min")
            + pd.Timedelta("2 hours 40 min")
            + pd.Timedelta("6 hours 11 min")
            + pd.Timedelta("1 hours 3 min")
            + pd.Timedelta("3 min 51 s"),
        ],
    }
)

df_CPU_v04 = pd.DataFrame(
    {
        "step": ["megSAPma", "megSAPvc", "megSAPcn", "megSAPsv", "megSAPdb"],
        "allocated": [15, 8, 2, 2, 2],
        "used": [15 * 0.211, 8 * 0.588, 2 * 0.468, 2 * 0.91, 2 * 0.114],
        "time": [
            pd.Timedelta("2 hours 41 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min") + pd.Timedelta("3 min 26 s"),
        ],
    }
)

df_memory_v03 = pd.DataFrame(
    {
        "step": ["megSAPma", "megSAPvc", "megSAPcn", "megSAPsv", "megSAPdb"],
        "allocated": [50, 50, 50, 50, 50],
        "used": [50 * 0.02, 50 * 0.328, 50 * 0.819, 50 * 0.022, 50 * 0.007],
        "time": [
            pd.Timedelta("2 hours 54 min"),
            pd.Timedelta("2 hours 54 min") + pd.Timedelta("2 hours 40 min"),
            pd.Timedelta("2 hours 54 min")
            + pd.Timedelta("2 hours 40 min")
            + pd.Timedelta("6 hours 11 min"),
            pd.Timedelta("2 hours 54 min")
            + pd.Timedelta("2 hours 40 min")
            + pd.Timedelta("6 hours 11 min")
            + pd.Timedelta("1 hours 3 min"),
            pd.Timedelta("2 hours 54 min")
            + pd.Timedelta("2 hours 40 min")
            + pd.Timedelta("6 hours 11 min")
            + pd.Timedelta("1 hours 3 min")
            + pd.Timedelta("3 min 51 s"),
        ],
    }
)

df_memory_v04 = pd.DataFrame(
    {
        "step": ["megSAPma", "megSAPvc", "megSAPcn", "megSAPsv", "megSAPdb"],
        "allocated": [2, 20, 48, 2, 2],
        "used": [2 * 0.494, 20 * 0.556, 48 * 0.379, 2 * 0.555, 2 * 0.335],
        "time": [
            pd.Timedelta("2 hours 41 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min") + pd.Timedelta("3 min 26 s"),
        ],
    }
)

figure_optimization = make_subplots(
    rows=2,
    cols=2,
    shared_yaxes=True,
    subplot_titles=("Initital","Optimiert"),
    horizontal_spacing=0.025,
    vertical_spacing=0.05,
    )

figure_optimization.add_trace(
    go.Bar(
        x=df_CPU_v03["step"],
        y=df_CPU_v03["allocated"],
        name="zugewiesen",
        marker_color=BENE_COLORS[0],
    ),
    row=1,
    col=1,
)

figure_optimization.add_trace(
    go.Bar(
        x=df_CPU_v03["step"],
        y=df_CPU_v03["used"],
        name="genutzt",
        marker_color=BENE_COLORS[1],
    ),
    row=1,
    col=1,
)

figure_optimization.add_trace(
    go.Bar(
        x=df_CPU_v04["step"],
        y=df_CPU_v04["allocated"],
        name="zugewiesen",
        marker_color=BENE_COLORS[0],
        showlegend=False
    ),
    row=1,
    col=2,
)

figure_optimization.add_trace(
    go.Bar(
        x=df_CPU_v04["step"],
        y=df_CPU_v04["used"],
        name="genutzt",
        marker_color=BENE_COLORS[1],
        showlegend=False
    ),
    row=1,
    col=2,
)

figure_optimization.add_trace(
    go.Bar(
        x=df_memory_v03["step"],
        y=df_memory_v03["allocated"],
        name="zugewiesen",
        marker_color=BENE_COLORS[0],
        showlegend=False
    ),
    row=2,
    col=1,
)

figure_optimization.add_trace(
    go.Bar(
        x=df_memory_v03["step"],
        y=df_memory_v03["used"],
        name="genutzt",
        marker_color=BENE_COLORS[1],
        showlegend=False
    ),
    row=2,
    col=1,
)

figure_optimization.add_trace(
    go.Bar(
        x=df_memory_v04["step"],
        y=df_memory_v04["allocated"],
        name="zugewiesen",
        marker_color=BENE_COLORS[0],
        showlegend=False
    ),
    row=2,
    col=2,
)

figure_optimization.add_trace(
    go.Bar(
        x=df_memory_v04["step"],
        y=df_memory_v04["used"],
        name="genutzt",
        marker_color=BENE_COLORS[1],
        showlegend=False
    ),
    row=2,
    col=2,
)

figure_optimization.update_layout(
    dict(
        paper_bgcolor='rgba(0,0,0,0)',
        template="plotly_white+bene",
        showlegend=True,
    )
)

figure_optimization.update_yaxes(title="CPU Kerne", row=1, col=1)
figure_optimization.update_yaxes(title="Arbeitsspeicher in GB", row=2, col=1)
figure_optimization.update_xaxes(showticklabels=False, row=1, col=1)
figure_optimization.update_xaxes(showticklabels=False, row=1, col=2)

figure_optimization.show()
```

## Artefakt - Resilienz und Monitoring
::::: {.blocker}
:::: {.center-y}
::: incremental
- Schritte werden neu gestartet mit mehr Arbeitsspeicher
- Email nach Abschluss Pipeline
:::
::::
:::::

# Kostenberechnung Cloudnutzung

## Kostenberechnung Cloudnutzung - AWS {.smaller}

| Beschreibung  | EC2 Instanztyp | CPUs | Arbeitsspeicher in GB | Kosten in $ |
|---------------|----------------|-----:|----------------------:|------------:|
| Speicher      |                |      |                       | 2,45        |
| Datentransfer |                |      |                       | 4,50        |
| bam2fastq     | t3.large       | 2    | 8                     | 0,16        |
| megSAPma      | c6i.4xlarge    | 16   | 32                    | 2,08        |
| megSAPvc      | t3.2xlarge     | 8    | 32                    | 1,15        |
| megSAPcn      | r5.2xlarge     | 8    | 64                    | 3,88        |
| megSAPsv      | t3.small       | 2    | 2                     | 0,04        |
| dragen        | f1.2xlarge     | 8    | 122                   | 12,08       |
| **Summe**     |                |      |                       | **26,34**   |

## Kostenberechnung Cloudnutzung - Upload mit AWS Snowball

::::: {.columns}

:::: {.column width="50%"}
::: {.center-y style='width:50%; text-align: center'}

![AWS Snowball[^AmazonWebServices2023d]](images/snowball.png){height="250"}

:::
::::
:::: {.column width="50%"}
::: {.center-y style='width:50%'}

- 300 $ für 10 Tage

- 80 TB HDD Kapazität

:::
::::
:::::

[^AmazonWebServices2023d]: Quelle: @AmazonWebServices2023d

# Diskussion

## Diskussion - Optimierung CPU Nutzung
```{python}
import pandas as pd
import plotly.io as pio
import plotly.graph_objects as go

BENE_COLORS = (
    "#47476B",
    "#CDA715",
    "#318986",
)
pio.templates["bene"] = go.layout.Template(
    layout=go.Layout(
        colorway=BENE_COLORS,
    )
)
pio.templates.default = "plotly_white+bene"

figure_aoc_cpu_compared = go.Figure()

df_CPU_v04 = pd.DataFrame(
    {
        "step": ["megSAPma", "megSAPvc", "megSAPcn", "megSAPsv", "megSAPdb"],
        "allocated": [15, 8, 2, 2, 2],
        "used": [15 * 0.211, 8 * 0.588, 2 * 0.468, 2 * 0.91, 2 * 0.114],
        "time": [
            pd.Timedelta("2 hours 41 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min") + pd.Timedelta("3 min 26 s"),
        ],
    }
)

figure_aoc_cpu_compared.add_trace(
    go.Scatter(
        x=[0,11.5],
        y=[12,12],
        fill="tozeroy",
        line_color=BENE_COLORS[0],
        mode="lines",
        name="initital zugewiesen",
    )
)

figure_aoc_cpu_compared.add_trace(
    go.Scatter(
        x=pd.concat([pd.Series([0]), df_CPU_v04["time"].dt.total_seconds() / 60 / 60]),
        y=pd.concat([pd.Series([df_CPU_v04["allocated"][0]]), df_CPU_v04["allocated"]]),
        fill="tozeroy",
        line_color=BENE_COLORS[2],
        #fillcolor=BENE_COLORS[1],
        line_shape="vh",
        mode="lines",
        name="optimiert zugewiesen",
    )
)

figure_aoc_cpu_compared.update_layout(
    dict(
        paper_bgcolor='rgba(0,0,0,0)',
        margin=dict(l=20, r=20, t=20, b=20),
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=1, xanchor="center", x=0.5),
        xaxis_title="Zeit in h",
        yaxis_title="CPU Kerne",
    )
)
figure_aoc_cpu_compared.show()
```
::: {.notes}
42,35 % Effizienter
:::

## Diskussion - Optimierung Speichernutzung
```{python}
import pandas as pd
import plotly.io as pio
import plotly.graph_objects as go

BENE_COLORS = (
    "#47476B",
    "#CDA715",
    "#318986",
)
pio.templates["bene"] = go.layout.Template(
    layout=go.Layout(
        colorway=BENE_COLORS,
    )
)
pio.templates.default = "plotly_white+bene"

df_memory_v04 = pd.DataFrame(
    {
        "step": ["megSAPma", "megSAPvc", "megSAPcn", "megSAPsv", "megSAPdb"],
        "allocated": [2, 20, 48, 2, 2],
        "used": [2 * 0.494, 20 * 0.556, 48 * 0.379, 2 * 0.555, 2 * 0.335],
        "time": [
            pd.Timedelta("2 hours 41 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min"),
            pd.Timedelta("2 hours 41 min") + pd.Timedelta("2 hours 59 min") + pd.Timedelta("6 hours 23 min") + pd.Timedelta("1 hours 28 min") + pd.Timedelta("3 min 26 s"),
        ],
    }
)

figure_aoc_memory_compared = go.Figure()

figure_aoc_memory_compared.add_trace(
    go.Scatter(
        x=[0,11.5],
        y=[50,50],
        fill="tozeroy",
        line_color=BENE_COLORS[0],
        #fillcolor=CUD_COLORS[1],
        mode="lines",
        name="initial zugewiesen",
    )
)

figure_aoc_memory_compared.add_trace(
    go.Scatter(
        x=pd.concat([pd.Series([0]), df_memory_v04["time"].dt.total_seconds() / 60 / 60]),
        y=pd.concat([pd.Series([df_memory_v04["allocated"][0]]), df_memory_v04["allocated"]]),
        fill="tozeroy",
        line_color=BENE_COLORS[2],
        #fillcolor=CUD_COLORS[1],
        line_shape="vh",
        mode="lines",
        name="optimiert zugewiesen",
    )
)

figure_aoc_memory_compared.update_layout(
    dict(
        paper_bgcolor='rgba(0,0,0,0)',
        margin=dict(l=20, r=20, t=20, b=20),
        template="plotly_white+bene",
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=1, xanchor="center", x=0.5),
        xaxis_title="Zeit in h",
        yaxis_title="Arbeitsspeicher in GB",
    )
)

figure_aoc_memory_compared.show()

```

::: {.notes}
34.87 % Effizienter
:::

## Diskussion - Kostenersparnis Cloud

:::: {.center-y}

"Nur" 11,56 % günstiger durch Optimierung: 26,33 \$ statt 29,77 \$

::: incremental
- Instanztypen passen nicht exakt
- DRAGEN größter Kostenfaktor
:::
::::
::: {.notes}
- 26,33 \$ statt 29,77 \$ 
- Lizenz DRAGEN kostet ca. 40 € (bei voller Auslastung)
- HPC Kosten nicht schätzbar
:::

# Fazit und Ausblick

## Fazit und Ausblick - Effizienzsteigerung

:::: {.center-y}
::: incremental
- Weitere, kontinuierliche Optimierung
- Aufteilung von *megSAP* in kleinere Schritte
- Speichern im *CRAM* Dateiformat
:::
::::

## Fazit und Ausblick - Usability

::::: {.columns}

:::: {.column width="50%"}
::: {.center-y style='width:50%'}

Nutzung Nextflow Tower

:::
::::
::::  {.column width="50%"}
::: {.center-y style='width:50%; text-align: center'}

![Screenshot Nextflow Tower](images/tower_screenshot.png)

:::
::::
:::::

## Fazit und Ausblick - Neuer Sequencer

::::: {.columns}
:::: {.column width="40%"}
::: {.center-y style='width:40%; text-align: center'}

![NovaSeq X Plus Produktbild[^IlluminaInc2022a]](images/novaseq_x.png){height="250"}

:::
::::
::::  {.column width="60%"}
::: {.center-y style='width:60%'}

Einführung NovaSeq X Plus ab Q3 2023 erfordert neue Pipeline

:::
::::
:::::

[^IlluminaInc2022a]: Quelle: @IlluminaInc2022a

# Quellenverzeichnis {visibility="uncounted" .unnumbered .unlisted}

::: {#refs}
:::